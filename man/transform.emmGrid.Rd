% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/emmGrid-methods.R
\name{transform.emmGrid}
\alias{transform.emmGrid}
\title{Modify variable names and/or levels in a reference grid}
\usage{
\method{transform}{emmGrid}(`_data`, ..., `_par` = list())
}
\arguments{
\item{...}{Specifications for changes to be made. See Specifications section}

\item{`_data`}{An object of class \code{emmGrid}}

\item{`_par`}{named \code{list} containing any additional parameters needed
in evaluating expressions}
}
\value{
a modified \code{emmGrid} object
}
\description{
Modify variable names and/or levels in a reference grid
}
\note{
An alternative way to use this is to supply a list of arguments as the \code{morph}
option in \code{\link{update.emmGrid}}.
}
\section{Specifications}{

Each specification can be of one of the following forms:
\itemize{
  \item{\code{name = <replacement levels>  } (replace levels only)}
  \item{\code{name = newname ~ <replacement levels>  } (replace levels and rename)}
  \item{\code{name = ~ <expression>  } (calculate new levels)}
  \item{\code{name = newname ~ <expression>  } (calculate new levels and rename)}
  \item{\code{newame ~ name  } (rename with levels unchanged)}
  \item{\code{newname ~ <expression>  } (calculate new levels for variable 
         in expression, and rename)}
}
Here, \code{name} must be the name of an existing predictor in the grid,
and \code{<replacement levels>} is a character of numeric vector of length
exactly equal to the number of levels of \code{name}. The type of the replacement levels
does not need to match the type of the existing levels; however, any factor in the grid
remains a factor, with its levels changed.

Expressions must be supplied via a formula, and must be evaluable in the context 
of \code{envir} and the existing levels of \code{name}.
If a formula has a left-hand side, it is used as
a replacement name for that variable.
}

\examples{
warp.lm <- lm(breaks ~ wool * tension, data = warpbreaks)
(warp.rg <- ref_grid(warp.lm))
transform(warp.rg, tension = 1:3,  wool = texture ~ c("soft", "coarse"))

# Standardized predictor
z <- scale(fiber$diameter)
fiber.lm <- lm(strength ~ z + machine, data = fiber)

### Mean predictions at 1-SD intervals:
(fiber.emm <- emmeans(fiber.lm, "z", at = list(z = -1:1)))

### Same predictions labeled with actual diameter values:
transform(fiber.emm, diameter ~ `scaled:center` + `scaled:scale` * z,
    `_par` = attributes(z))

### NOTE: alling environment is also available, so could also use:
#>    transform(fiber.emm, diameter ~ mean(fiber$diameter) + sd(fiber$diameter) * z)

}
